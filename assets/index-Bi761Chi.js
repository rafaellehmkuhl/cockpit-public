import{c8 as m,c9 as X,ca as T,cb as f,cc as D,cd as w,ce as g,cf as W,cg as b,ch as O,ci as x,cj as q,ck as J,cl as K,cm as Q,cn as $}from"./index-DUOq3AX3.js";import{cw as de,cz as le,cK as ue,cC as he,cy as pe,cx as Re,cB as me,ct as fe,cL as Ee,cR as ye,cN as De,cM as we,cQ as ge,cP as _e,cF as Ne,cG as Se,cO as Ie,cA as Te,cI as be,cH as Oe,cT as Ae,cE as Pe,cD as ze,cS as Ue,cU as xe,cq as Fe,cr as Ce,cs as We,cp as Be,cv as Ze,cJ as Le,cu as Me,co as ve,cV as He}from"./index-DUOq3AX3.js";class B{constructor(e,t,r,a){const s=this;if(e.root&&a&&a.getChildByName(t))throw new Error("Entry filename already exists");r||(r={}),Object.assign(s,{fs:e,name:t,data:r.data,options:r.options,id:e.entries.length,parent:a,children:[],uncompressedSize:r.uncompressedSize||0,passThrough:r.passThrough}),e.entries.push(s),a&&s.parent.children.push(s)}moveTo(e){const t=this;t.fs.move(t,e)}getFullname(){return this.getRelativeName()}getRelativeName(e=this.fs.root){const t=this;let r=t.name,a=t.parent;for(;a&&a!=e;)r=(a.name?a.name+"/":"")+r,a=a.parent;return r}isDescendantOf(e){let t=this.parent;for(;t&&t.id!=e.id;)t=t.parent;return!!t}rename(e){const t=this.parent;if(t&&t.getChildByName(e))throw new Error("Entry filename already exists");this.name=e}}class _ extends B{constructor(e,t,r,a){super(e,t,r,a);const s=this;s.Reader=r.Reader,s.Writer=r.Writer,r.getData&&(s.getData=r.getData)}clone(){return new _(this.fs,this.name,this)}async getData(e,t={}){const r=this;if(!e||e.constructor==r.Writer&&r.data)return r.data;{const a=r.reader=new r.Reader(r.data,t),s=r.data?r.data.uncompressedSize:a.size;await Promise.all([m(a),m(e,s)]);const{readable:o}=a;return r.uncompressedSize=a.size,await o.pipeTo(e.writable),e.getData?e.getData():e.writable}}isPasswordProtected(){return this.data.encrypted}async checkPassword(e,t={}){const r=this;if(r.isPasswordProtected()){t.password=e,t.checkPasswordOnly=!0;try{return await r.data.getData(null,t),!0}catch(a){if(a.message==X)return!1;throw a}}else return!0}getText(e,t){return this.getData(new T(e),t)}getBlob(e,t){return this.getData(new f(e),t)}getData64URI(e,t){return this.getData(new D(e),t)}getUint8Array(e){return this.getData(new w,e)}getWritable(e=new WritableStream,t){return this.getData({writable:e},t)}getArrayBuffer(e){return this.data.arrayBuffer(e)}replaceBlob(e){Object.assign(this,{data:e,Reader:g,Writer:f,reader:null})}replaceText(e){Object.assign(this,{data:e,Reader:W,Writer:T,reader:null})}replaceData64URI(e){Object.assign(this,{data:e,Reader:b,Writer:D,reader:null})}replaceUint8Array(e){Object.assign(this,{data:e,Reader:O,Writer:w,reader:null})}replaceReadable(e){Object.assign(this,{data:null,Reader:function(){return{readable:e}},Writer:null,reader:null})}}class h extends B{constructor(e,t,r,a){super(e,t,r,a),this.directory=!0}clone(e){const t=this,r=new h(t.fs,t.name);return e&&(r.children=t.children.map(a=>{const s=a.clone(e);return s.parent=r,s})),r}addDirectory(e,t){return l(this,e,{options:t},!0)}addText(e,t,r={}){return l(this,e,{data:t,Reader:W,Writer:T,options:r,uncompressedSize:t.length})}addBlob(e,t,r={}){return l(this,e,{data:t,Reader:g,Writer:f,options:r,uncompressedSize:t.size})}addData64URI(e,t,r={}){let a=t.length;for(;t.charAt(a-1)=="=";)a--;const s=t.indexOf(",")+1;return l(this,e,{data:t,Reader:b,Writer:D,options:r,uncompressedSize:Math.floor((a-s)*.75)})}addUint8Array(e,t,r={}){return l(this,e,{data:t,Reader:O,Writer:w,options:r,uncompressedSize:t.length})}addHttpContent(e,t,r={}){return l(this,e,{data:t,Reader:class extends x{constructor(a){super(a,r)}},options:r})}addReadable(e,t,r={}){return l(this,e,{Reader:function(){return{readable:t}},options:r})}addFileSystemEntry(e,t={}){return C(this,e,t)}addFileSystemHandle(e,t={}){return C(this,e,t)}addFile(e,t={}){return t.lastModDate||(t.lastModDate=new Date(e.lastModified)),l(this,e.name,{data:e,Reader:function(){const r=e.stream(),a=e.size;return{readable:r,size:a}},options:t,uncompressedSize:e.size})}addData(e,t){return l(this,e,t)}importBlob(e,t){return this.importZip(new g(e),t)}importData64URI(e,t){return this.importZip(new b(e),t)}importUint8Array(e,t){return this.importZip(new O(e),t)}importHttpContent(e,t){return this.importZip(new x(e,t),t)}importReadable(e,t){return this.importZip({readable:e},t)}exportBlob(e={}){return this.exportZip(new f(e.mimeType||"application/zip"),e)}exportData64URI(e={}){return this.exportZip(new D(e.mimeType||"application/zip"),e)}exportUint8Array(e={}){return this.exportZip(new w,e)}async exportWritable(e=new WritableStream,t={}){return await this.exportZip({writable:e},t),e}async importZip(e,t={}){await m(e);const r=new q(e,t),a=[],s=await r.getEntries();for(const o of s){let n=this;try{const c=o.filename.split("/"),p=c.pop();c.forEach((R,d)=>{const E=n;n=n.getChildByName(R),n||(n=new h(this.fs,R,{data:d==c.length-1?o:null},E),a.push(n))}),o.directory||a.push(l(n,p,{data:o,Reader:re(Object.assign({},t)),uncompressedSize:o.uncompressedSize,passThrough:t.passThrough}))}catch(c){try{c.cause={entry:o}}catch{}throw c}}return a}async exportZip(e,t){const r=this;t.bufferedWrite===J&&(t.bufferedWrite=!0),await Promise.all([Z(r,t.readerOptions),m(e)]);const a=new K(e,t);return await ae(a,r,te([r],"uncompressedSize"),t),await a.close(),e.getData?e.getData():e.writable}getChildByName(e){const t=this.children;for(let r=0;r<t.length;r++){const a=t[r];if(a.name==e)return a}}isPasswordProtected(){const e=this.children;for(let t=0;t<e.length;t++)if(e[t].isPasswordProtected())return!0;return!1}async checkPassword(e,t={}){const r=this.children;return!(await Promise.all(r.map(s=>s.checkPassword(e,t)))).includes(!1)}}class ee{constructor(){u(this)}get children(){return this.root.children}remove(e){F(e),this.entries[e.id]=null}move(e,t){if(e==this.root)throw new Error("Root directory cannot be moved");if(t.directory){if(t.isDescendantOf(e))throw new Error("Entry is a ancestor of target entry");if(e!=t){if(t.getChildByName(e.name))throw new Error("Entry filename already exists");F(e),e.parent=t,t.children.push(e)}}else throw new Error("Target entry is not a directory")}find(e){const t=e.split("/");let r=this.root;for(let a=0;r&&a<t.length;a++)r=r.getChildByName(t[a]);return r}getById(e){return this.entries[e]}getChildByName(e){return this.root.getChildByName(e)}addDirectory(e,t){return this.root.addDirectory(e,t)}addText(e,t,r){return this.root.addText(e,t,r)}addBlob(e,t,r){return this.root.addBlob(e,t,r)}addData64URI(e,t,r){return this.root.addData64URI(e,t,r)}addUint8Array(e,t,r){return this.root.addUint8Array(e,t,r)}addHttpContent(e,t,r){return this.root.addHttpContent(e,t,r)}addReadable(e,t,r){return this.root.addReadable(e,t,r)}addFileSystemEntry(e,t){return this.root.addFileSystemEntry(e,t)}addFileSystemHandle(e,t){return this.root.addFileSystemHandle(e,t)}addFile(e,t){return this.root.addFile(e,t)}addData(e,t){return this.root.addData(e,t)}importBlob(e,t){return u(this),this.root.importBlob(e,t)}importData64URI(e,t){return u(this),this.root.importData64URI(e,t)}importUint8Array(e,t){return u(this),this.root.importUint8Array(e,t)}importHttpContent(e,t){return u(this),this.root.importHttpContent(e,t)}importReadable(e,t){return u(this),this.root.importReadable(e,t)}importZip(e,t){return this.root.importZip(e,t)}exportBlob(e){return this.root.exportBlob(e)}exportData64URI(e){return this.root.exportData64URI(e)}exportUint8Array(e){return this.root.exportUint8Array(e)}exportWritable(e,t){return this.root.exportWritable(e,t)}isPasswordProtected(){return this.root.isPasswordProtected()}checkPassword(e,t){return this.root.checkPassword(e,t)}}const ne={FS:ee,ZipDirectoryEntry:h,ZipFileEntry:_};function te(i,e){let t=0;return i.forEach(r),t;function r(a){t+=a[e],a.children&&a.children.forEach(r)}}function re(i){return class extends Q{constructor(e,t={}){super(),this.entry=e,this.options=t}async init(){const e=this;e.size=e.entry.uncompressedSize;const t=await e.entry.getData(new f,Object.assign({},e.options,i));e.data=t,e.blobReader=new g(t),super.init()}readUint8Array(e,t){return this.blobReader.readUint8Array(e,t)}}}async function Z(i,e){i.children.length&&await Promise.all(i.children.map(async t=>{if(t.directory)await Z(t,e);else{const r=t.reader=new t.Reader(t.data,e);try{await m(r)}catch(a){try{a.entryId=t.id,a.cause={entry:t}}catch{}throw a}t.uncompressedSize=r.size}}))}function F(i){if(i.parent){const e=i.parent.children;e.forEach((t,r)=>{t.id==i.id&&e.splice(r,1)})}}async function ae(i,e,t,r){const a=e,s=new Map;await o(i,e);async function o(n,c){await p();async function p(){if(r.bufferedWrite)await Promise.allSettled(c.children.map(R));else for(const d of c.children)await R(d)}async function R(d){const E=r.relativePath?d.getRelativeName(a):d.getFullname(),M=d.options||{};let y={};if(d.data instanceof $){const{externalFileAttributes:N,versionMadeBy:S,comment:I,lastModDate:v,creationDate:H,lastAccessDate:V,uncompressedSize:k,encrypted:j,zipCrypto:Y,signature:G,compressionMethod:A,extraFieldAES:P}=d.data;if(y={externalFileAttributes:N,versionMadeBy:S,comment:I,lastModDate:v,creationDate:H,lastAccessDate:V},d.passThrough){let z,U;A===0&&(z=0),P&&(U=P.strength),y=Object.assign(y,{passThrough:!0,encrypted:j,zipCrypto:Y,signature:G,uncompressedSize:k,level:z,encryptionStrength:U,compressionMethod:A})}}await n.add(E,d.reader,Object.assign({},r,y,M,{directory:d.directory,onprogress:async N=>{if(r.onprogress){s.set(E,N);try{await r.onprogress(Array.from(s.values()).reduce((S,I)=>S+I),t)}catch{}}}})),await o(n,d)}}}function C(i,e,t){return r(i,e,[]);async function r(a,s,o){if(s)try{if((s.isFile||s.isDirectory)&&(s=await L(s)),s.kind=="file"){const n=await s.getFile();o.push(a.addData(n.name,{Reader:function(){const c=n.stream(),p=n.size;return{readable:c,size:p}},options:Object.assign({},{lastModDate:new Date(n.lastModified)},t),uncompressedSize:n.size}))}else if(s.kind=="directory"){const n=a.addDirectory(s.name);o.push(n);for await(const c of s.values())await r(n,c,o)}}catch(n){const c=n.message+(s?" ("+s.name+")":"");throw new Error(c)}return o}}async function L(i){const e={name:i.name};if(i.isFile&&(e.kind="file",e.getFile=()=>new Promise((t,r)=>i.file(t,r))),i.isDirectory){e.kind="directory";const t=await se(i);e.values=()=>t}return e}async function se(i){const e=[];function t(r,a,s){r.readEntries(async o=>{if(!o.length)a(e);else{for(const n of o)e.push(await L(n));t(r,a,s)}},s)}return await new Promise((r,a)=>t(i.createReader(),r,a)),{[Symbol.iterator](){let r=0;return{next(){const a={value:e[r],done:r==e.length};return r++,a}}}}}function u(i){i.entries=[],i.root=new h(i)}function l(i,e,t,r){if(i.directory)return r?new h(i.fs,e,t,i):new _(i.fs,e,t,i);throw new Error("Parent entry is not a directory")}export{g as BlobReader,f as BlobWriter,b as Data64URIReader,D as Data64URIWriter,de as ERR_BAD_FORMAT,le as ERR_CENTRAL_DIRECTORY_NOT_FOUND,ue as ERR_DUPLICATED_NAME,he as ERR_ENCRYPTED,pe as ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND,Re as ERR_EOCDR_NOT_FOUND,me as ERR_EXTRAFIELD_ZIP64_NOT_FOUND,fe as ERR_HTTP_RANGE,Ee as ERR_INVALID_COMMENT,ye as ERR_INVALID_ENCRYPTION_STRENGTH,De as ERR_INVALID_ENTRY_COMMENT,we as ERR_INVALID_ENTRY_NAME,ge as ERR_INVALID_EXTRAFIELD_DATA,_e as ERR_INVALID_EXTRAFIELD_TYPE,X as ERR_INVALID_PASSWORD,Ne as ERR_INVALID_SIGNATURE,Se as ERR_INVALID_UNCOMPRESSED_SIZE,Ie as ERR_INVALID_VERSION,Te as ERR_LOCAL_FILE_HEADER_NOT_FOUND,be as ERR_OVERLAPPING_ENTRY,Oe as ERR_SPLIT_ZIP_FILE,Ae as ERR_UNDEFINED_UNCOMPRESSED_SIZE,Pe as ERR_UNSUPPORTED_COMPRESSION,ze as ERR_UNSUPPORTED_ENCRYPTION,Ue as ERR_UNSUPPORTED_FORMAT,xe as ERR_ZIP_NOT_EMPTY,Fe as HttpRangeReader,x as HttpReader,Q as Reader,Ce as SplitDataReader,We as SplitDataWriter,W as TextReader,T as TextWriter,O as Uint8ArrayReader,w as Uint8ArrayWriter,Be as Writer,q as ZipReader,Ze as ZipReaderStream,K as ZipWriter,Le as ZipWriterStream,Me as configure,ne as fs,ve as getMimeType,He as terminateWorkers};

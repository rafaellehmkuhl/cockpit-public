{"version":3,"file":"MiniVideoRecorder-AZBxlnsN.js","sources":["../../src/components/mini-widgets/MiniVideoRecorder.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"recorderWidget\"\n    class=\"flex justify-around px-2 py-1 text-center rounded-lg w-40 h-9 align-center bg-slate-800/60\"\n  >\n    <div\n      v-if=\"!isProcessingVideo\"\n      :class=\"{\n        'blob red w-5 opacity-100 rounded-sm': isRecording,\n        'opacity-30 bg-red-400': isOutside && !isRecording,\n      }\"\n      class=\"w-6 transition-all duration-500 rounded-full aspect-square bg-red-lighten-1 hover:cursor-pointer opacity-70 hover:opacity-90\"\n      @click=\"toggleRecording()\"\n    />\n    <div v-else>\n      <v-icon class=\"w-6 h-6 animate-spin\" color=\"white\">mdi-loading</v-icon>\n    </div>\n    <template v-if=\"!isRecording && !isProcessingVideo\">\n      <div\n        v-if=\"nameSelectedStream\"\n        class=\"flex flex-col max-w-[50%] scroll-container transition-all border-blur cursor-pointer\"\n        @click=\"widgetStore.miniWidgetManagerVars(miniWidget.hash).configMenuOpen = true\"\n      >\n        <div class=\"text-xs text-white select-none scroll-text\">{{ nameSelectedStream }}</div>\n      </div>\n      <FontAwesomeIcon v-else icon=\"fa-solid fa-video\" class=\"h-6 text-slate-100\" />\n    </template>\n    <div v-if=\"isRecording && !isProcessingVideo\" class=\"w-16 text-justify text-slate-100\">\n      {{ timePassedString }}\n    </div>\n    <div v-else-if=\"isProcessingVideo\" class=\"w-16 text-justify text-slate-100\">\n      <div class=\"text-xs text-center text-white select-none flex-nowrap\">Processing video...</div>\n    </div>\n    <div class=\"flex justify-center w-6\">\n      <v-divider vertical class=\"h-6 ml-1\" />\n      <v-badge\n        color=\"info\"\n        :content=\"numberOfVideosOnDB\"\n        :dot=\"isOutside || isVideoLibraryDialogOpen\"\n        class=\"cursor-pointer\"\n        @click=\"openVideoLibraryModal\"\n      >\n        <v-icon class=\"w-6 h-6 ml-1 text-slate-100\" @click=\"openVideoLibraryModal\"> mdi-video-box </v-icon></v-badge\n      >\n    </div>\n  </div>\n  <v-dialog v-model=\"widgetStore.miniWidgetManagerVars(miniWidget.hash).configMenuOpen\" width=\"auto\">\n    <div\n      class=\"flex flex-col items-center p-2 pt-1 m-5 rounded-md gap-y-4\"\n      :style=\"interfaceStore.globalGlassMenuStyles\"\n    >\n      <p class=\"text-xl font-semibold m-4\">Choose a stream to record</p>\n      <v-select\n        :model-value=\"nameSelectedStream\"\n        label=\"Stream name\"\n        :items=\"namesAvailableStreams\"\n        item-title=\"name\"\n        density=\"compact\"\n        variant=\"outlined\"\n        no-data-text=\"No streams available.\"\n        hide-details\n        return-object\n        theme=\"dark\"\n        class=\"w-[90%]\"\n        @update:model-value=\"updateCurrentStream\"\n      />\n      <div class=\"flex w-full justify-between items-center mt-4\">\n        <v-btn\n          class=\"w-auto text-uppercase\"\n          variant=\"text\"\n          @click=\"widgetStore.miniWidgetManagerVars(miniWidget.hash).configMenuOpen = false\"\n        >\n          Close\n        </v-btn>\n        <v-btn\n          class=\"bg-[#FFFFFF11] hover:bg-[#FFFFFF33]\"\n          size=\"large\"\n          :class=\"{ 'opacity-30 pointer-events-none': isLoadingStream }\"\n          @click=\"startRecording\"\n        >\n          <span>Record</span>\n          <v-icon v-if=\"isLoadingStream\" class=\"m-2 animate-spin\">mdi-loading</v-icon>\n          <div v-else class=\"w-5 h-5 ml-2 rounded-full bg-red\" />\n        </v-btn>\n      </div>\n    </div>\n  </v-dialog>\n</template>\n\n<script setup lang=\"ts\">\nimport { useMouseInElement, useTimestamp } from '@vueuse/core'\nimport { intervalToDuration } from 'date-fns'\nimport { storeToRefs } from 'pinia'\nimport { computed, onBeforeMount, onBeforeUnmount, onMounted, ref, toRefs, watch } from 'vue'\n\nimport { useInteractionDialog } from '@/composables/interactionDialog'\nimport { isEqual, sleep } from '@/libs/utils'\nimport { useAppInterfaceStore } from '@/stores/appInterface'\nimport { useVideoStore } from '@/stores/video'\nimport { useWidgetManagerStore } from '@/stores/widgetManager'\nimport type { MiniWidget } from '@/types/widgets'\n\nconst { showDialog } = useInteractionDialog()\nconst interfaceStore = useAppInterfaceStore()\nconst widgetStore = useWidgetManagerStore()\nconst videoStore = useVideoStore()\n\nconst props = defineProps<{\n  /**\n   * Configuration of the widget\n   */\n  miniWidget: MiniWidget\n}>()\nconst miniWidget = toRefs(props).miniWidget\n\nconst nameSelectedStream = ref<string | undefined>()\nconst { namessAvailableAbstractedStreams: namesAvailableStreams } = storeToRefs(videoStore)\nconst recorderWidget = ref()\nconst { isOutside } = useMouseInElement(recorderWidget)\nconst isVideoLibraryDialogOpen = ref(false)\nconst isLoadingStream = ref(false)\nconst timeNow = useTimestamp({ interval: 100 })\nconst mediaStream = ref<MediaStream | undefined>()\nconst isProcessingVideo = ref(false)\nconst numberOfVideosOnDB = ref(0)\nconst selectedExternalId = ref<string | undefined>()\n\nconst externalStreamId = computed(() => selectedExternalId.value)\n\nconst openVideoLibraryModal = (): void => {\n  interfaceStore.videoLibraryVisibility = true\n}\n\nwatch(\n  () => videoStore.streamsCorrespondency,\n  () => (mediaStream.value = undefined),\n  { deep: true }\n)\n\nonMounted(async () => {\n  await fetchNumberOfTempVideos()\n})\n\nonBeforeMount(async () => {\n  // Set initial widget options if they don't exist\n  if (Object.keys(miniWidget.value.options).length === 0) {\n    miniWidget.value.options = {\n      internalStreamName: undefined as string | undefined,\n    }\n  }\n  nameSelectedStream.value = miniWidget.value.options.internalStreamName\n\n  if (nameSelectedStream.value) {\n    selectedExternalId.value = videoStore.externalStreamId(nameSelectedStream.value)\n  }\n})\n\nwatch(nameSelectedStream, () => {\n  miniWidget.value.options.internalStreamName = nameSelectedStream.value\n  mediaStream.value = undefined\n})\n\nwatch(\n  () => videoStore.streamsCorrespondency,\n  (newStreamsCorrespondency) => {\n    if (!selectedExternalId.value) return\n\n    const matchingStream = newStreamsCorrespondency.find((stream) => stream.externalId === selectedExternalId.value)\n\n    if (matchingStream) {\n      if (nameSelectedStream.value !== matchingStream.name) {\n        nameSelectedStream.value = matchingStream.name\n      }\n    } else {\n      // The externalId no longer exists; handle accordingly\n      nameSelectedStream.value = undefined\n      selectedExternalId.value = undefined\n    }\n  },\n  { deep: true }\n)\n\nwatch(nameSelectedStream, (newName) => {\n  selectedExternalId.value = newName ? videoStore.externalStreamId(newName) : undefined\n  miniWidget.value.options.internalStreamName = newName\n  mediaStream.value = undefined\n})\n\n// Fetch number of temporary videos on storage\nconst fetchNumberOfTempVideos = async (): Promise<void> => {\n  const nProcessedVideos = (await videoStore.videoStoringDB.keys()).filter((k) => videoStore.isVideoFilename(k)).length\n  const nFailedUnprocessedVideos = Object.keys(videoStore.keysFailedUnprocessedVideos).length\n  numberOfVideosOnDB.value = nProcessedVideos + nFailedUnprocessedVideos\n}\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction assertStreamIsSelectedAndAvailable(\n  selectedStream: undefined | string\n): asserts selectedStream is NonNullable<undefined | string> {\n  nameSelectedStream.value = selectedStream\n\n  if (nameSelectedStream.value === undefined) {\n    showDialog({ message: 'No stream selected.', variant: 'error' })\n    return\n  }\n\n  if (namesAvailableStreams.value.includes(nameSelectedStream.value)) return\n\n  const errorMsg = `The selected stream is not available. Please check its source or select another stream.`\n  showDialog({ message: errorMsg, variant: 'error' })\n  throw new Error(errorMsg)\n}\n\nconst toggleRecording = async (): Promise<void> => {\n  if (isRecording.value) {\n    if (selectedExternalId.value) {\n      videoStore.stopRecording(selectedExternalId.value)\n    }\n    return\n  }\n\n  if (!nameSelectedStream.value) {\n    widgetStore.miniWidgetManagerVars(miniWidget.value.hash).configMenuOpen = true\n    return\n  }\n\n  startRecording()\n}\n\nconst startRecording = (): void => {\n  if (!selectedExternalId.value) {\n    showDialog({ title: 'Cannot start recording.', message: 'No stream selected.', variant: 'error' })\n    return\n  }\n\n  if (!videoStore.getStreamData(selectedExternalId.value)?.connected) {\n    showDialog({ title: 'Cannot start recording.', message: 'Stream is not connected.', variant: 'error' })\n    return\n  }\n\n  assertStreamIsSelectedAndAvailable(nameSelectedStream.value)\n  videoStore.startRecording(selectedExternalId.value)\n  widgetStore.miniWidgetManagerVars(miniWidget.value.hash).configMenuOpen = false\n}\n\nconst isRecording = computed(() => {\n  if (!selectedExternalId.value) return false\n  return videoStore.isRecording(selectedExternalId.value)\n})\n\nconst timePassedString = computed(() => {\n  if (externalStreamId.value === undefined) return '00:00:00'\n  const timeRecordingStart = videoStore.getStreamData(externalStreamId.value)?.timeRecordingStart\n  if (timeRecordingStart === undefined) return '00:00:00'\n\n  const duration = intervalToDuration({ start: timeRecordingStart, end: timeNow.value })\n  const durationHours = duration.hours?.toFixed(0).length === 1 ? `0${duration.hours}` : duration.hours\n  const durationMinutes = duration.minutes?.toFixed(0).length === 1 ? `0${duration.minutes}` : duration.minutes\n  const durationSeconds = duration.seconds?.toFixed(0).length === 1 ? `0${duration.seconds}` : duration.seconds\n  return `${durationHours}:${durationMinutes}:${durationSeconds}`\n})\n\nconst updateCurrentStream = async (internalStreamName: string | undefined): Promise<void> => {\n  assertStreamIsSelectedAndAvailable(internalStreamName)\n\n  mediaStream.value = undefined\n  isLoadingStream.value = true\n\n  let millisPassed = 0\n  const timeStep = 100\n  const waitingTime = 3000\n  while (isLoadingStream.value && millisPassed < waitingTime) {\n    // @ts-ignore: The media stream can (and probably will) get defined as we selected a stream\n    isLoadingStream.value = mediaStream.value === undefined || !mediaStream.value.active\n    await sleep(timeStep)\n    millisPassed += timeStep\n  }\n\n  if (isLoadingStream.value) {\n    showDialog({ message: 'Could not load media stream.', variant: 'error' })\n    return\n  }\n\n  miniWidget.value.options.internalStreamName = internalStreamName\n}\n\nlet streamConnectionRoutine: ReturnType<typeof setInterval> | undefined = undefined\n\nif (widgetStore.isRealMiniWidget(miniWidget.value.hash)) {\n  streamConnectionRoutine = setInterval(() => {\n    // If the video recording widget is cold booted, assign the first stream to it\n    if (miniWidget.value.options.internalStreamName === undefined && !namesAvailableStreams.value.isEmpty()) {\n      miniWidget.value.options.internalStreamName = namesAvailableStreams.value[0]\n      nameSelectedStream.value = miniWidget.value.options.internalStreamName\n    }\n\n    // If the stream name is defined, try to connect the widget to the MediaStream\n    if (externalStreamId.value !== undefined) {\n      const updatedMediaStream = videoStore.getMediaStream(miniWidget.value.options.internalStreamName)\n      // If the widget is not connected to the MediaStream, try to connect it\n      if (!isEqual(updatedMediaStream, mediaStream.value)) {\n        mediaStream.value = updatedMediaStream\n      }\n    }\n  }, 1000)\n}\nonBeforeUnmount(() => clearInterval(streamConnectionRoutine))\n\n// Check if there are videos being processed\nwatch(\n  () => videoStore.areThereVideosProcessing,\n  (newValue) => {\n    isProcessingVideo.value = newValue\n    fetchNumberOfTempVideos()\n  }\n)\n\nwatch(\n  () => videoStore.keysFailedUnprocessedVideos,\n  () => fetchNumberOfTempVideos()\n)\n\nwatch(\n  () => isVideoLibraryDialogOpen.value,\n  async (newValue) => {\n    if (newValue === false) {\n      await fetchNumberOfTempVideos()\n    }\n  }\n)\n\n// Try to prevent user from closing Cockpit when a stream is being recorded\nwatch(isRecording, () => {\n  if (!isRecording.value) {\n    window.onbeforeunload = null\n    return\n  }\n  window.onbeforeunload = () => {\n    const alertMsg = `\n      You have a video recording ongoing.\n      Remember to stop it before closing Cockpit, or the record will be lost.\n    `\n    showDialog({ message: alertMsg, variant: 'warning' })\n    return 'I hope the user does not click on the leave button.'\n  }\n})\n</script>\n\n<style scoped>\n.blob.red {\n  background: rgba(255, 82, 82, 1);\n  box-shadow: 0 0 0 0 rgba(255, 82, 82, 1);\n  animation: pulse-red 2s infinite;\n}\n\n@keyframes pulse-red {\n  0% {\n    transform: scale(0.95);\n    box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.7);\n  }\n\n  70% {\n    transform: scale(1);\n    box-shadow: 0 0 0 10px rgba(255, 82, 82, 0);\n  }\n\n  100% {\n    transform: scale(0.95);\n    box-shadow: 0 0 0 0 rgba(255, 82, 82, 0);\n  }\n}\n\n.scroll-container {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.scroll-text {\n  transform: translateX(0%);\n  transition: transform 1s linear;\n}\n\n.scroll-text:hover {\n  transform: translateX(-100%);\n}\n\n.border-blur:hover {\n  background-color: #475569;\n  box-shadow: 0px 0px 3px 3px #475569;\n}\n\n.close-icon {\n  position: absolute;\n  top: 5px;\n  right: 5px;\n  cursor: pointer;\n  font-size: 20px;\n  color: #999;\n}\n</style>\n"],"names":["showDialog","useInteractionDialog","interfaceStore","useAppInterfaceStore","widgetStore","useWidgetManagerStore","videoStore","useVideoStore","miniWidget","toRefs","__props","nameSelectedStream","ref","namesAvailableStreams","storeToRefs","recorderWidget","isOutside","useMouseInElement","isVideoLibraryDialogOpen","isLoadingStream","timeNow","useTimestamp","mediaStream","isProcessingVideo","numberOfVideosOnDB","selectedExternalId","externalStreamId","computed","openVideoLibraryModal","watch","onMounted","fetchNumberOfTempVideos","onBeforeMount","newStreamsCorrespondency","matchingStream","stream","newName","nProcessedVideos","k","nFailedUnprocessedVideos","assertStreamIsSelectedAndAvailable","selectedStream","errorMsg","toggleRecording","isRecording","startRecording","_a","timePassedString","timeRecordingStart","duration","intervalToDuration","durationHours","_b","durationMinutes","_c","durationSeconds","_d","updateCurrentStream","internalStreamName","millisPassed","timeStep","waitingTime","sleep","streamConnectionRoutine","updatedMediaStream","isEqual","onBeforeUnmount","newValue"],"mappings":"6gCAsGM,KAAA,CAAE,WAAAA,GAAeC,KACjBC,EAAiBC,KACjBC,EAAcC,KACdC,EAAaC,KAQbC,EAAaC,GANLC,CAMiB,EAAE,WAE3BC,EAAqBC,IACrB,CAAE,iCAAkCC,CAAsB,EAAIC,GAAYR,CAAU,EACpFS,EAAiBH,IACjB,CAAE,UAAAI,CAAA,EAAcC,GAAkBF,CAAc,EAChDG,EAA2BN,EAAI,EAAK,EACpCO,EAAkBP,EAAI,EAAK,EAC3BQ,EAAUC,GAAa,CAAE,SAAU,GAAK,CAAA,EACxCC,EAAcV,IACdW,EAAoBX,EAAI,EAAK,EAC7BY,EAAqBZ,EAAI,CAAC,EAC1Ba,EAAqBb,IAErBc,EAAmBC,EAAS,IAAMF,EAAmB,KAAK,EAE1DG,EAAwB,IAAY,CACxC1B,EAAe,uBAAyB,EAAA,EAG1C2B,EACE,IAAMvB,EAAW,sBACjB,IAAOgB,EAAY,MAAQ,OAC3B,CAAE,KAAM,EAAK,CAAA,EAGfQ,GAAU,SAAY,CACpB,MAAMC,EAAwB,CAAA,CAC/B,EAEDC,GAAc,SAAY,CAEpB,OAAO,KAAKxB,EAAW,MAAM,OAAO,EAAE,SAAW,IACnDA,EAAW,MAAM,QAAU,CACzB,mBAAoB,MAAA,GAGLG,EAAA,MAAQH,EAAW,MAAM,QAAQ,mBAEhDG,EAAmB,QACrBc,EAAmB,MAAQnB,EAAW,iBAAiBK,EAAmB,KAAK,EACjF,CACD,EAEDkB,EAAMlB,EAAoB,IAAM,CACnBH,EAAA,MAAM,QAAQ,mBAAqBG,EAAmB,MACjEW,EAAY,MAAQ,MAAA,CACrB,EAEDO,EACE,IAAMvB,EAAW,sBAChB2B,GAA6B,CAC5B,GAAI,CAACR,EAAmB,MAAO,OAEzB,MAAAS,EAAiBD,EAAyB,KAAME,GAAWA,EAAO,aAAeV,EAAmB,KAAK,EAE3GS,EACEvB,EAAmB,QAAUuB,EAAe,OAC9CvB,EAAmB,MAAQuB,EAAe,OAI5CvB,EAAmB,MAAQ,OAC3Bc,EAAmB,MAAQ,OAE/B,EACA,CAAE,KAAM,EAAK,CAAA,EAGTI,EAAAlB,EAAqByB,GAAY,CACrCX,EAAmB,MAAQW,EAAU9B,EAAW,iBAAiB8B,CAAO,EAAI,OACjE5B,EAAA,MAAM,QAAQ,mBAAqB4B,EAC9Cd,EAAY,MAAQ,MAAA,CACrB,EAGD,MAAMS,EAA0B,SAA2B,CACzD,MAAMM,GAAoB,MAAM/B,EAAW,eAAe,KAAK,GAAG,OAAQgC,GAAMhC,EAAW,gBAAgBgC,CAAC,CAAC,EAAE,OACzGC,EAA2B,OAAO,KAAKjC,EAAW,2BAA2B,EAAE,OACrFkB,EAAmB,MAAQa,EAAmBE,CAAA,EAIhD,SAASC,EACPC,EAC2D,CAGvD,GAFJ9B,EAAmB,MAAQ8B,EAEvB9B,EAAmB,QAAU,OAAW,CAC1CX,EAAW,CAAE,QAAS,sBAAuB,QAAS,OAAS,CAAA,EAC/D,MACF,CAEA,GAAIa,EAAsB,MAAM,SAASF,EAAmB,KAAK,EAAG,OAEpE,MAAM+B,EAAW,0FACjB,MAAA1C,EAAW,CAAE,QAAS0C,EAAU,QAAS,OAAS,CAAA,EAC5C,IAAI,MAAMA,CAAQ,CAC1B,CAEA,MAAMC,EAAkB,SAA2B,CACjD,GAAIC,EAAY,MAAO,CACjBnB,EAAmB,OACVnB,EAAA,cAAcmB,EAAmB,KAAK,EAEnD,MACF,CAEI,GAAA,CAACd,EAAmB,MAAO,CAC7BP,EAAY,sBAAsBI,EAAW,MAAM,IAAI,EAAE,eAAiB,GAC1E,MACF,CAEeqC,GAAA,EAGXA,EAAiB,IAAY,OAC7B,GAAA,CAACpB,EAAmB,MAAO,CAC7BzB,EAAW,CAAE,MAAO,0BAA2B,QAAS,sBAAuB,QAAS,QAAS,EACjG,MACF,CAEA,GAAI,GAAC8C,EAAAxC,EAAW,cAAcmB,EAAmB,KAAK,IAAjD,MAAAqB,EAAoD,WAAW,CAClE9C,EAAW,CAAE,MAAO,0BAA2B,QAAS,2BAA4B,QAAS,QAAS,EACtG,MACF,CAEAwC,EAAmC7B,EAAmB,KAAK,EAChDL,EAAA,eAAemB,EAAmB,KAAK,EAClDrB,EAAY,sBAAsBI,EAAW,MAAM,IAAI,EAAE,eAAiB,EAAA,EAGtEoC,EAAcjB,EAAS,IACtBF,EAAmB,MACjBnB,EAAW,YAAYmB,EAAmB,KAAK,EADhB,EAEvC,EAEKsB,EAAmBpB,EAAS,IAAM,aACtC,GAAID,EAAiB,QAAU,OAAkB,MAAA,WACjD,MAAMsB,GAAqBF,EAAAxC,EAAW,cAAcoB,EAAiB,KAAK,IAA/C,YAAAoB,EAAkD,mBAC7E,GAAIE,IAAuB,OAAkB,MAAA,WAEvC,MAAAC,EAAWC,GAAmB,CAAE,MAAOF,EAAoB,IAAK5B,EAAQ,MAAO,EAC/E+B,IAAgBC,EAAAH,EAAS,QAAT,YAAAG,EAAgB,QAAQ,GAAG,UAAW,EAAI,IAAIH,EAAS,KAAK,GAAKA,EAAS,MAC1FI,IAAkBC,EAAAL,EAAS,UAAT,YAAAK,EAAkB,QAAQ,GAAG,UAAW,EAAI,IAAIL,EAAS,OAAO,GAAKA,EAAS,QAChGM,IAAkBC,EAAAP,EAAS,UAAT,YAAAO,EAAkB,QAAQ,GAAG,UAAW,EAAI,IAAIP,EAAS,OAAO,GAAKA,EAAS,QACtG,MAAO,GAAGE,CAAa,IAAIE,CAAe,IAAIE,CAAe,EAAA,CAC9D,EAEKE,EAAsB,MAAOC,GAA0D,CAC3FlB,EAAmCkB,CAAkB,EAErDpC,EAAY,MAAQ,OACpBH,EAAgB,MAAQ,GAExB,IAAIwC,EAAe,EACnB,MAAMC,EAAW,IACXC,EAAc,IACb,KAAA1C,EAAgB,OAASwC,EAAeE,GAE7C1C,EAAgB,MAAQG,EAAY,QAAU,QAAa,CAACA,EAAY,MAAM,OAC9E,MAAMwC,GAAMF,CAAQ,EACJD,GAAAC,EAGlB,GAAIzC,EAAgB,MAAO,CACzBnB,EAAW,CAAE,QAAS,+BAAgC,QAAS,OAAS,CAAA,EACxE,MACF,CAEWQ,EAAA,MAAM,QAAQ,mBAAqBkD,CAAA,EAGhD,IAAIK,EAEJ,OAAI3D,EAAY,iBAAiBI,EAAW,MAAM,IAAI,IACpDuD,EAA0B,YAAY,IAAM,CAQtC,GANAvD,EAAW,MAAM,QAAQ,qBAAuB,QAAa,CAACK,EAAsB,MAAM,YAC5FL,EAAW,MAAM,QAAQ,mBAAqBK,EAAsB,MAAM,CAAC,EACxDF,EAAA,MAAQH,EAAW,MAAM,QAAQ,oBAIlDkB,EAAiB,QAAU,OAAW,CACxC,MAAMsC,EAAqB1D,EAAW,eAAeE,EAAW,MAAM,QAAQ,kBAAkB,EAE3FyD,GAAQD,EAAoB1C,EAAY,KAAK,IAChDA,EAAY,MAAQ0C,EAExB,GACC,GAAI,GAEOE,GAAA,IAAM,cAAcH,CAAuB,CAAC,EAG5DlC,EACE,IAAMvB,EAAW,yBAChB6D,GAAa,CACZ5C,EAAkB,MAAQ4C,EACFpC,GAC1B,CAAA,EAGFF,EACE,IAAMvB,EAAW,4BACjB,IAAMyB,EAAwB,CAAA,EAGhCF,EACE,IAAMX,EAAyB,MAC/B,MAAOiD,GAAa,CACdA,IAAa,IACf,MAAMpC,EAAwB,CAElC,CAAA,EAIFF,EAAMe,EAAa,IAAM,CACnB,GAAA,CAACA,EAAY,MAAO,CACtB,OAAO,eAAiB,KACxB,MACF,CACA,OAAO,eAAiB,KAKtB5C,EAAW,CAAE,QAJI;AAAA;AAAA;AAAA,MAIe,QAAS,SAAW,CAAA,EAC7C,sDACT,CACD"}